using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;
using Shouldly;
using VerifyNUnit;
using VerifyTests;

// ReSharper disable InconsistentNaming

namespace BuilderGenerator.Tests.Unit;

[TestFixture]
public class When_generating_a_Builder_without_internals : Given_a_BuilderGenerator
{
    [Test]
    public Task SimpleGeneratorTest()
    {
        var assembly = GetType().Assembly;
        var inputCompilation = CreateCompilation(GetResourceAsString(assembly, "InputWithoutInternals.cs"));
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new BuilderGenerator());
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        diagnostics.ShouldBeEmpty();
        outputCompilation.SyntaxTrees.Count().ShouldBe(4);

        var runResult = driver.GetRunResult();
        runResult.Diagnostics.ShouldBeEmpty();
        runResult.GeneratedTrees.Length.ShouldBe(3); // The Builder base class, the BuilderFor attribute, and the generated builder

        // TODO: Check for the presence of the Builder base class.
        // TODO: Check for the presence of the BuilderForAttribute class.

        var generatorResult = runResult.Results[0];
        generatorResult.Generator.GetGeneratorType().ShouldBe(new BuilderGenerator().GetType());
        generatorResult.Exception.ShouldBeNull();
        generatorResult.GeneratedSources.Length.ShouldBe(3);

        var output = generatorResult.GeneratedSources[2].SourceText.ToString();
        var settings = new VerifySettings();
        settings.ScrubLinesContaining("This code was generated by BuilderGenerator");
        settings.UseDirectory("Verify");
        return Verifier.Verify(output, settings);
    }
}
