using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;
using Shouldly;

namespace BuilderGenerator.UnitTests;

[TestFixture]
public class GeneratorTests
{
    [Test]
    public void SimpleGeneratorTest()
    {
        // Create the 'input' compilation that the generator will act on
        var inputCompilation = CreateCompilation(
            @"
using BuilderGenerator;

namespace BuilderGenerator.UnitTests
{
    public class Person
    {
        public string FirstName { get; set; }
    }

    [BuilderFor(typeof(Person))]
    public partial class PersonBuilder
    {
    }
}
");

        var expectedOutput = @"// <auto-generated>
using BuilderGenerator;
using System.CodeDom.Compiler;

#nullable disable

namespace BuilderGenerator.UnitTests
{
    public partial class PersonBuilder : BuilderGenerator.Builder<BuilderGenerator.UnitTests.Person>
    {
        public System.Lazy<string> FirstName = new System.Lazy<string>(() => default(string));

        public override BuilderGenerator.UnitTests.Person Build()
        {
            if (Object?.IsValueCreated != true)
            {
                Object = new System.Lazy<BuilderGenerator.UnitTests.Person>(() => 
                {
                    var result = new BuilderGenerator.UnitTests.Person 
                    {
                        FirstName = FirstName.Value,
                    };

                    return result;
                });

                PostProcess(Object.Value);
            }

            return Object.Value;
        }

        public PersonBuilder WithFirstName(string value)
        {
            return WithFirstName(() => value);
        }

        public PersonBuilder WithFirstName(System.Func<string> func)
        {
            FirstName = new System.Lazy<string>(func);
            return this;
        }

        public PersonBuilder WithoutFirstName()
        {                    
            FirstName = new System.Lazy<string>(() => default(string));
            return this;
        }
    }
}";

        var generator = new BuilderGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        diagnostics.ShouldBeEmpty();
        outputCompilation.SyntaxTrees.Count().ShouldBe(4);

        //outputCompilation.GetDiagnostics().ShouldBeEmpty();

        var runResult = driver.GetRunResult();
        runResult.Diagnostics.ShouldBeEmpty();

        runResult.GeneratedTrees.Length.ShouldBe(3); // The Builder base class, the BuilderFor attribute, and the generated builder.

        // TODO: Check for the presence of the Builder base class.
        // TODO: Check for the presence of the BuilderForAttribute class.

        var generatorResult = runResult.Results[0];
        generatorResult.Generator.GetGeneratorType().ShouldBe(generator.GetType());
        generatorResult.Exception.ShouldBeNull();
        generatorResult.GeneratedSources.Length.ShouldBe(3);
        generatorResult.GeneratedSources[2].SourceText.ToString().ShouldBe(expectedOutput);
    }

    private static Compilation CreateCompilation(string source)
        => CSharpCompilation.Create(
            "compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
}
