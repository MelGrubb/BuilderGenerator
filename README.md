# BuilderGenerator #
A source-generator-based implementation of the Builder pattern

# First Steps #
Create a project to hold the source generator itself. I'm calling mine "BuilderGenerator". The builder doesn't actually need to target a specific framework version, so either choose "netstandard2.0" when creating the project, or alter the csproj file as follows.

```csharp
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>preview</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="3.8.0-3.final" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.0.0" PrivateAssets="all" />
  </ItemGroup>

</Project>
```

Remember to save your project file before continuing, or Visual Studio may get confused. This project can now be used as a source generator. We just need to fill in something for it to generate. Let's create our "BuilderGenerator" class. You can call this anything you want, but I'll name it the same as the project and solution just to keep things simple. Decorate it with the "Microsoft.CodeAnalysis.Generator" attribute, implement the "ISourceGenerator" interface, and you should end up with something that looks like this.

```csharp
using System;
using Microsoft.CodeAnalysis;

namespace BuilderGenerator
{
    [Generator]
    public class BuilderGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            throw new NotImplementedException();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            throw new NotImplementedException();
        }
    }
}
```

Rather than throwing exceptions, which won't get us very far, let's start building out some code. We'll start off small, with a class that says "Hello World!".

```csharp
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace BuilderGenerator
{
    [Generator]
    public class BuilderGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Nothing to do... yet.
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var builder = new StringBuilder(@"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     BuilderGenerator v1.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace Generated
{
    public class Greetings
    {
        public static HelloWorld()
        {
            return ""Hello World!"";
        }
    }
}");

            context.AddSource("Greetings.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }
}
```

## Using the Source Generator ##

Now that we have a source generator, albeit a boring one, let's add it to a project to see it in action. Add a second project to the solution. I'm calling mine "Demo.Domain", and it will be taking the place of a typical domain layer, defining various entities. This project can safely target core framework versions. The result should look something like this:

```csharp
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <LangVersion>preview</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\BuilderGenerator\BuilderGenerator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
  </ItemGroup>

</Project>
```

This will generate code that lives in the Demo.Domain project itself, although you won't be able to see it when you're editing. You can, however, make references to it from other classes and/or projects, so let's see if we can find it. Add a unit test project to the solution. I'll call mine "Demo.Tests". Add a reference to the Domain project, and then create our first test, called "GreetingsTests"

```csharp
using NUnit.Framework;

namespace Demo.Tests
{
    [TestFixture]
    public class GreetingsTests
    {
        [Test]
        public void SayHello_returns_expected_string()
        {
            Assert.AreEqual("Hello World!", Generated.Greetings.HelloWorld());
        }
    }
}
```

You may see some Intellisense errors at this point, and will have to restart Visual Studio before continuing. It appears to me that Visual Studio loads up the analyzer once, when loading the solution, and will keep using that analyzer for the rest of that session. This may or may not accurately describe what is really going on behind the scenes, but it's certainly the observed effect. Any time you make a change to the generator itself, you'll have to restart Visual Studio to take advantage of the changes. Once the generator itself is finished, you should be able to go about using it "live" without any problems, but working on the template itself is going to be a bit of a chore in the meantime. Restart Visual Studio and Intellisense should start working again, including auto-complete. Hopefully these errors will go away in later releases.

## Generating Real Code ##

Now that we have a working source generator, let's make it do something more useful than returning "Hello World". Let's start simply. For each entity class (e.g. Foo), we want to generate a corresponding "Builder" class (e.g. FooBuilder). The contents aren't important yet, just that we can generate the class, and then refer to it from other classes within the same project, or from the tests.

First, we'll create an attribute with which to mark classes we want to create builders for. Unfortunately, we can't do this from within the BuilderGenerator project itself, at least not at this time. Our Domain project is referencing the BuilderGenerator project, but it's doing it as an "Analyzer", not as a library, so we can't make direct use of the classes defined there. Instead, we'll have to create a separate project to hold the attribute. Add a new "BuilderGenerator.Common" project to the solution. Within that project, create an "Attributes" folder, and finally, create a new attribute as follows:


```csharp
using System;

namespace BuilderGenerator.Core.Attributes
{
    [AttributeUsage(AttributeTargets.Class)]
    public class GenerateBuilderAttribute : Attribute
    {
    }
}
```

Next, in the Domain project, create a folder to hold our entity definitions. I'll call mine "Entities". Create a new entity called "Foo" in the "Entities" folder. 

```csharp
using BuilderGenerator.Core.Attributes;

namespace Demo.Domain.Entities
{
    [GenerateBuilder]
    public class Foo
    {
    }
}
```

Again, the contents are not important at this stage. We just want to generate a class for each entity with the attribute. To start with, replace the contents of the BuilderGenerator.Execute method with the following:

```csharp
        public void Execute(GeneratorExecutionContext context)
        {
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var root = syntaxTree.GetRoot();
                var usingBlock = ((CompilationUnitSyntax) root).Usings.ToString();

                var classesWithAttribute = root
                    .DescendantNodes()
                    .OfType<ClassDeclarationSyntax>()
                    .Where(cds => cds.AttributeLists.HasAttribute(nameof(GenerateBuilderAttribute)))
                    .ToList();

                foreach (var classDeclaration in classesWithAttribute)
                {
                    var @namespace = "Demo.Domain.Entities.Builders.Generated";
                    var className = classDeclaration.Identifier.Text;
                    var builderName = $"{className}Builder";

                    var builder = new StringBuilder($@"
using System;
{usingBlock}

namespace {@namespace}
{{
    public partial class {builderName}
    {{
    }}
}}");

                    context.AddSource($"{className}Builder.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
                }
            }
        }
```

There are a few things going on here. First, we loop through all of the available "Syntax Trees". These represent all the different assemblies available to the builder. Since the BuilderGenerator has been loaded as an analyzer for the Domain project, it should expect the Domain project to be one of those syntax trees. Within that syntax tree, we want compile a list of all the different "using" statements in play. We'll put these at the top of each generated file we create. Next, we look for any classes in the syntax tree that have the marker attribute, and loop through them. Within each iteration of the loop, we will create a builder class to match the source class, and add it to the "context", which effectively makes it part of the project that is being compiled at the time.

Delete the old GreetingsTests class, and replace it with a new "BuilderTests" class that looks like this:

```csharp
using Demo.Domain.Entities.Builders.Generated;
using NUnit.Framework;

namespace Demo.Tests
{
    [TestFixture]
    public class BuilderTests
    {
        [Test]
        public void FooBuilder_exists()
        {
            var actual = new FooBuilder();
            Assert.IsInstanceOf<FooBuilder>(actual);
        }
    }
}
```

At this point, you'll probably have to restart Visual Studio for Intellisense to work again. This is going to happen each time we make a change to the BuilderGenerator class, or at least every time we add some new feature. If you run this test, it should pass, and now we can test the system by adding a new entity. Create a new "Bar" entity in the same folder as "Foo" and save it. Without restarting Visual Studio, you should be able to add another test to BuilderTests, and have it work immediately.


```csharp
        [Test]
        public void BarBuilder_exists()
        {
            var actual = new BarBuilder();
            Assert.IsInstanceOf<BarBuilder>(actual);
        }
```
## Refactoring ##

Before we go much further, let's take a moment to refactor a bit.